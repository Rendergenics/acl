
#pragma once

#include <compare>
#include <concepts>
#include <cstdint>
#include <limits>

namespace acl::ecs
{

template <typename Ty, typename SizeType = uint32_t, uint32_t RevisionBits = 0>
class basic_entity
{
public:
  static_assert(RevisionBits < sizeof(SizeType) * 8, "Revision bits must be less than the SizeType");

  using revision_type =
    std::conditional_t<RevisionBits == 0, void, std::conditional_t<(RevisionBits > 8), uint16_t, uint8_t>>;

  using size_type                             = SizeType;
  static constexpr size_type null_v           = 0;
  static constexpr size_type nb_revision_bits = RevisionBits;
  static constexpr size_type nb_usable_bits   = (sizeof(size_type) * 8 - nb_revision_bits);
  static constexpr size_type index_mask_v     = std::numeric_limits<size_type>::max() >> nb_revision_bits;
  static constexpr size_type revision_mask_v  = std::numeric_limits<size_type>::max() << nb_usable_bits;
  static constexpr size_type version_inc_v    = 1 << nb_usable_bits;

  constexpr basic_entity() noexcept                      = default;
  constexpr basic_entity(basic_entity const& i) noexcept = default;
  constexpr explicit basic_entity(size_type i) noexcept : i_(i) {}
  constexpr explicit basic_entity(size_type i, size_type revision) noexcept
    requires(nb_revision_bits > 0)
      : i_(revision << nb_usable_bits | i)
  {}

  constexpr basic_entity& operator=(basic_entity const& i) noexcept = default;

  constexpr inline explicit operator size_type() const noexcept
  {
    if constexpr (nb_revision_bits > 0)
      return (i_ & index_mask_v);
    else
      return i_;
  }

  constexpr inline size_type revision() const noexcept
    requires(nb_revision_bits > 0)
  {
    return i_ >> nb_usable_bits;
  }

  constexpr inline basic_entity revised() const noexcept
    requires(nb_revision_bits > 0)
  {
    return basic_entity(i_ + version_inc_v);
  }

  constexpr inline size_type get() const noexcept
  {
    return i_;
  }

private:
  size_type i_ = {};
};

template <typename T>
using entity = basic_entity<T, uint32_t>;

template <typename T>
using rxentity = basic_entity<T, uint32_t, 8>;

} // namespace acl::ecs
